---

title: 面经
data: 2025/3/17

tags:
  - 面经 unity 八股
categories:
  - 知识

---


# Unity 客户端开发
## 八股
- 平衡二叉树的原理和在stl数据结构中的应用  
- 线程和进程的区别
    - **进程是资源分配的单位，线程是执行的单位**。进程之间相互独立，线程共享进程资源，并且线程切换比进程切换更快，适用于需要高效并行计算的场景。
    - 
        | **特性**           | **栈（Stack）**                               | **堆（Heap）**                                 |
        |--------------------|----------------------------------------------|-----------------------------------------------|
        | **内存分配**       | 自动分配和释放                               | 手动分配和释放（`new` / `malloc` 和 `delete` / `free`） |
        | **管理方式**       | 由编译器管理，基于栈顶指针（LIFO）            | 由程序员管理，可以在程序运行期间动态分配和释放  |
        | **分配效率**       | 非常快，因为栈的管理遵循后进先出（LIFO）规则   | 比栈慢，因为需要查找空闲空间并进行内存管理     |
        | **生命周期**       | 局部变量的生命周期仅在函数调用期间           | 可以在函数调用之间保持，直到显式释放          |
        | **大小限制**       | 栈的大小通常较小，受操作系统限制             | 堆的大小通常较大，取决于系统的可用内存        |
        | **内存访问**       | 快速，数据存储紧凑                           | 比栈慢，内存管理复杂，且分配后可能分散         |
        | **溢出情况**       | 栈溢出（栈空间不足，通常是递归调用过深）      | 堆溢出（堆内存不足，通常是内存泄漏导致的）     |

## cpp
- 重写和重载的区别 重写是虚函数的重写，重载是函数名相同，参数不同 √  
- c的内存对齐 
    - 存对齐是指数据在内存中存储时按照特定的规则进行排列，使得数据能够高效地访问。内存对齐的主要目的是提高处理器的访问速度，因为许多处理器在访问内存时要求数据按特定边界对齐。若数据不对齐，可能导致性能下降，甚至引发错误
    - 例如在结构体中char 类型通常按 1 字节对齐，int 类型通常按 4 字节对齐。所以，编译器会在 a 和 b 之间插入 3 个填充字节，确保 b 按 4 字节对齐。结构体的大小可能会超过成员总大小，因此可能会有额外的填充字节。
    - ```c
        #include <stdio.h>

        struct MyStruct {
        char a;       // 1字节
        int b;        // 4字节
        char c;       // 1字节
        };

        int main() 
        {
            struct MyStruct s;
            printf("Size of MyStruct: %lu\n", sizeof(s));  // 打印结构体的大小
            return 0;
        }
        ```
- c和c++内存管理的区别
    - 在 C 中，内存分配是通过标准库函数 malloc()、calloc() 和 realloc() 来完成的，而内存释放则通过 free() 完成。
    - C++ 也支持 C 风格的内存管理（malloc() 和 free()），但它更倾向于使用 C++ 风格的内存管理——通过 new 和 delete 操作符来分配和释放内存。
    - C++ 还支持对象的构造和析构：new 会调用构造函数，delete 会调用析构函数。对于数组，new[] 会调用每个元素的构造函数，而 delete[] 会调用每个元素的析构函数。
    - C 语言：
        C 语言不提供对象的构造和析构功能。你需要手动管理结构体成员的初始化与清理。
        C++ 语言：
        在 C++ 中，内存管理是与对象的生命周期紧密结合的。C++ 类和对象通过构造函数和析构函数来初始化和清理资源。
- 会哪些寻路算法（DFS,BFS,Dijkstra，A*，B*） A*具体实现  
  最短路径dijkstra时间复杂度  
 dijkstra的限制，为什么不能求有负权边的图中最短路径  
- 二维平面上有一个迷宫，怎么从各个点到终点搜索路径  
- malloc 和 new 的区别  1
    - 内存分配方面 malloc 是 C 语言中的内存分配函数，用于动态分配一块指定大小的内存。
        它只负责分配内存，不会调用任何构造函数。
        malloc 返回的是 void* 类型的指针，通常需要强制类型转换。
    - 会不会调用构造、析构函数

- 为什么需要拷贝构造函数，为什么不直接赋值成员变量？  
    - 如果对象中有指向动态分配内存的指针，直接成员赋值可能会导致浅拷贝，即新对象和原对象指向同一块内存。这可能导致一系列问题，如双重释放（在析构时两次释放同一内存）或者内存泄漏（如果某个对象被销毁后，没有正确清理资源）。拷贝构造函数的作用就是在复制对象时进行深拷贝，确保每个对象都拥有自己独立的资源。
- 拷贝构造函数的参数  
    - 常量引用
- 类对象的引用，传值会导致递归调用  
- 内联函数
    - 内联函数是一种建议编译器在调用该函数的地方将其替换为函数体的实际代码，而不是通过正常的函数调用机制（即栈操作）来执行。这意味着，内联函数通过在编译时将函数体“嵌入”到调用点，避免了常规函数调用的开销（如压栈、弹栈、跳转等）。
- 为什么会递归调用，具体的过程  

- 函数覆盖的实现  
- 如何找到当前对象对应的虚函数  
- 函数重载的实现：哪些些函数能重载，不同返回值的同名函数为什么不能重载？  
- C++中多态的实现  
- 类的对象所占的空间：一个父类有纯虚函数，子类实现了虚函数，有一个int变量和一个bool变量  
## C#
- **协程和主程的区别**   
***协程， 我们又称为微线程，协程它不像线程和进程那样，需要进行系统内核上的上下文切换，协程的上下文切换是由开发人员决定的。***
协程就是在unity主线程运行时开启另外一段逻辑来协助运行，来模拟多线程。使用场景多用于异步、动画、等待等操作，最常见的就是进度条异步加载。原理是利用了像list、Dictionary内部使用的迭代器，但是使用方法不同，不是迭代元素，而是分帧执行代码。每一帧调用迭代器的方法（MoveNext），其中unity利用关键字yield return快速实现了迭代器，两个
yield return之间就是MoveNext方法执行的内容。  

进程和线程的区别

## 算法
- vector中扩容的过程，push n次所需时间复杂度  
- 归并排序 描述+时间复杂度推导  
- 如果分成3部分进行归并，复杂度推导  
- 快速排序 描述+时间复杂度推导  
- 堆的作用  

## 图形学 
1. ***PBR*** 一种基于物理的渲染 pbr就是物理光照建模，然后合理的数学解法。
2. 介绍SSAO  
3. 介绍法线贴图，凹凸贴图，视差贴图，置换贴图以及其区别  
4. 了解URP吗  
5. 介绍一下线性空间和伽马空间  

## 数据结构
1. 哈希表  
   结合了C#的Dictionary的源码说了以下  

2. 红黑树  
   
   结合std::map 然后说了一下红黑树的设计目的，解决了什么问题  

- 什么是图  

# 手撕代码
- 滑动窗口  
- 将原本的k个连续子数组的最大值改成>=k个连续子数组的最大值  
- 前缀和

# 网络
## web socket
- 握手过程：WebSocket 从 HTTP 协议升级而来，因此客户端首先会向服务器发起一个 HTTP 请求，服务器回应请求并返回 WebSocket 协议升级的响应。
- 持久连接：一旦建立连接，客户端和服务器之间可以随时发送数据，直到连接关闭。
- **全双工通信**：客户端和服务器都可以在任何时间发送数据，并且可以**异步**接收数据。

## 网络结构
- 物理层
- 数据链路层
    - 封装成帧，差错检测，可靠传输
- 网络层
    - IP协议，路由选择。ICMP，ARP，RARP
- 传输层
    - TCP，UDP,两个进程之间的通信，用端口号标识不同的进程
- 应用层
    - HTTP，FTP，SMTP，DNS，DHCP，TELNET，HTTPS，SSH，SSL，TLS
    - HTTP和HTTPS的区别
        - HTTP是无加密协议，数据传输是明文的，HTTPS是加密协议，通过SSL/TLS加密传输数据
        - HTTPS需要一个由受信任的证书颁发机构（CA）颁发的 SSL/TLS 证书。该证书用于验证服务器的身份，并确保与客户端的连接是安全的。
        - HTTPS使用的端口号是443，而HTTP使用的端口号是80。
        - HTTP 网站在搜索引擎优化（SEO）方面可能会受到一定影响，尤其是在 Google 等搜索引擎中，使用 HTTP 协议的网站会被视为不安全，可能会导致排名下降。
HTTPS 被 Google 和其他搜索引擎视为安全网站，并且会优先考虑使用 HTTPS 的网站，在 SEO 排名上可能会有一定优势。

## 算法面试题

介绍一下数据结构中的堆

介绍一下堆排序的过程 两个操作

空间复杂度是怎样的 O(logn)

是稳定的吗 不是

讲一下建堆的过程

建堆是从哪个结点开始的

用两个栈实现队列

怎么判断链表有没有环

接着刚刚的算法{哈希表}，怎么找到环的入口

可以讲下快慢指针怎么找环的入口吗

C++

递归深度过深会出现什么问题

简单介绍一下什么是面向对象设计

知道多态的实现原理吗

C++的类默认会有哪些函数

怎么阻止编译器创建默认的构造函数

子类和父类的构造函数执行顺序是怎样的

构造函数可以调用虚函数吗

子类的析构函数不是虚函数会有什么问题

怎么让类的所有实例之间共享数据

静态数据成员会影响类的大小吗

如果静态数据成员是私有的，那么还可以通过类名限定访问到吗

new和malloc有什么区别

内联函数的作用是什么

有什么缺点吗

和宏有什么区别

了解右值引用吗

怎么将一个左值转换为右值

介绍一下STL

vector和list的区别是啥

对于插入和删除，哪个数据结构效率更高

计算机基础

绍一下线程和进程的概念

线程有自己的资源吗

它共享了进程的哪些资源



# 2025/2/25完美世界日常实习面经 挂了

## 语言
- C++的三大特性
- 多态是怎么实现的
- 什么是虚函数
- 空类里面有哪些函数
    - 默认构造函数
    - 析构函数
    - 拷贝构造函数 用于通过已有对象初始化新对象
    - 拷贝赋值运算符 将一个对象的值赋给另一个对象
    - 移动构造函数 用于将一个右值引用绑定到一个左值上
- 如何让一个类不被实例化？仅有一个实例？
    - 在类中声明至少一个纯虚函数，类就会变成抽象类，抽象类不能被直接实例化，需要通过继承来实现。
    - 将构造函数设为protected 或者 private 适用于单例模式，工具类等
    - 使用c++11 的delete关键字，显示的删除构造函数，告诉编译器默认构造函数不可用
- static关键字是干嘛的？作用是？
    - 取决于上下文，可以修饰变量，函数，类，成员函数
    - 在函数内（局部变量中）当一个变量为static时，该变量的生命周期将延续到程序的整个运行周期，而不是在函数调用结束时销毁
    - 在全局变量或函数的内部链接中，使用static修饰变量或函数时，作用域被限制在当前编译单元中，外部无法访问
    - 声明类内静态成员。在类中，使用static声明的成员变量和成员函数属于类本身，而不是某个特定的对象，意味着所有该类的对象共享同一个静态成员，直接用ClassName::count, ClassName::func()访问
- const 关键字的作用
    - 修饰变量，表示该变量的值不可改变
    - 修饰指针，表示指针指向的值不可改变
        - const int *p 表示指针p指向的值不可改变，但是指针p本身可以改变
        - int * const p 表示指针p本身不可改变，但是指针p指向的值可以改变
        - const int * const p 表示指针p本身和指针p指向的值都不可改变
        - 在函数参数中，const修饰的参数表示该参数是只读的，不能被修改
        - 类成员函数中修饰函数，可以保证函数内部不会修改成员变量
- 什么是引用？引用和指针的区别？
    - **初始化和绑定**
        引用：声明时必须进行初始化，并且初始化后不能更改引用的对象。
        
        指针：可以在声明时不初始化，并且可以随时改变指向其他对象。
    - **语法使用**
        引用：使用时与普通变量一样，不需要额外的解引用操作。
        
        指针：使用时需要使用 * 运算符来解引用，访问其所指向的对象；使用 -> 运算符来访问对象的成员。
    - **是否可以为 null**
        引用：在标准 C++ 中，引用必须绑定到一个合法对象，不能是 null。
        
        指针：可以指向 null（如 nullptr），也可以在运行时改变指向。
    - **内存和实现细节**
        引用：通常在编译阶段由编译器处理，内部实现上可能就是一个指针，但对使用者来说，它更像是变量的另一个名字，不需要考虑内存地址。
        
        指针：本身就是一个存储内存地址的变量，需要管理其指向的内存，可能涉及动态分配和释放。
    - **运算**
        引用：不能进行算术运算或改变其绑定目标。
        
    - **指针**：可以进行算术运算（如指针加减），这在数组操作和动态内存管理中非常有用。
- 学过操作系统吗？进程和线程的区别
- 死锁是怎么形成的
    - 互斥条件
        - 至少有一个资源必须处于非共享模式，即某个时刻只能由一个进程使用
    - 请求和保持条件
        - 一个进程已经持有至少一个资源，同时又请求其他正在被其他进程占用的资源，而且在等待过程中不释放已占用的资源。
    - 不可剥夺条件
        - 已经分配给一个进程的资源，在未使用完毕之前不能被强制收回，只能由进程在使用完毕后主动释放。
    - 循环等待条件
        - 存在一种进程资源的循环等待关系，即进程A等待进程B持有的资源，进程B又等待进程C持有的资源，……最终某个进程又等待进程A持有的资源，从而形成一个闭环。
- 讲讲数据库索引是怎么实现的
    - 
- 讲讲tcp和udp的区别
- 讲讲三次握手
- 讲讲断开的时候是怎么断开的
    - 四次挥手，我给说成两次了xd
    

## Unity
- 假如一次生成10000000个对象，如何快速检索到一个对象？
- 对Unity的内存释放有了解吗？
- 说说协程吧
- 
## 图形学
- “我的知识集中在骨骼动画”，直接跳过了很多xd
    - 那你说说unity里面的骨骼动画吧
- 为什么要引入齐次坐标
- 有了解过相机正交和透视的区别吗
    - 透视相机的投影矩阵是怎么计算的
